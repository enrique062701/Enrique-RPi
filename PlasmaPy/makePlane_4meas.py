import numpy as npimport osimport matplotlib.pyplot as pltfrom mpl_toolkits.mplot3d import axes3dname = 'actionList_plane4_coarse.txt'def make_plane(x_start, x_stop, y_start, y_stop, z1, z2, z3, z4, x_bin, y_bin, m_offset, rep=1,                 mode='P', l_d='x', l_pos=0):    '''    Make plane or linear action list from 4 corner reference points. Coordinates are motor coordinates.    Note that coordinates are generated from small to large, so if you want to, say, go away from target in     the y direction you should modify y iteration    x_start: smaller x coordinate of the reference points    x_stop: larger x coordinate of the reference points    y_start: smaller y coordinate of the reference points    y_stop: larger y coordinates of the reference points    z1, z2, z3, z4: four z coordinates of the 4 corners, in the order of x from small to large and then y from small to large.    In other words, z1 at (x_start, y_start), z2 at (x_stop, y_start), z3 at (x_start, y_stop), z4 at (x_stop, y_stop).    x_bin: number of bins in the x direction. Number of data points in the x direction is thus x_bin + 1.    y_bin: number of bins in the y direction. These bins are also used in lineout modes    m_offset: offset for the mirror coordinates. mirror_coordinate = motor_coordinate + m_offset    rep: number of repetitions for each spatial point    mode: set plane ('P') or lineout ('L') modes    l_d: axis along which lineout points are taken    l_pos: position where lineout is taken, in absolute coordinates. For example, if you want to take lineouts in y direction,     l_pos is the x coordinate of these lineout points    WARNING: lineout modes have not been verified. Please check actionlist before implementing    '''    dir = './'    file = open(os.path.join(dir, name), 'w')    file.write('RESOURCE ID=124' '\t' 'RESOURCE ID=124' '\t' 'RESOURCE ID=124' '\t' 'RESOURCE ID=122' '\n'               'CHANNEL ID=0' '\t' 'CHANNEL ID=1' '\t' 'CHANNEL ID=2' '\t' 'CHANNEL ID=0' '\n'               'UNIT=MM' '\t' 'UNIT=MM' '\t' 'UNIT=MM' '\t' 'UNIT=MM' '\n' '###')    if mode == 'P':        b = np.indices((x_bin + 1, y_bin + 1))        xf = b[0] / x_bin        yf = b[1] / y_bin        z = (1 - xf - yf + xf*yf) * z1 + (xf - xf*yf) * z2 + (yf - xf*yf) * z3 + xf * yf * z4                z = np.around(z, 4) # NOTE: here you can set significant digit for the action list        xx = np.linspace(x_start, x_stop, x_bin + 1)        yy = np.linspace(y_start, y_stop, y_bin + 1)        x, y = np.meshgrid(xx, yy)        # reverse index        for i in range(1, x_bin+1,2):            y[:,i] = np.flip(y[:,i])            z[i] = np.flip(z[i])                                # z = np.flip(z)        # x = np.flip(x)                        x = np.transpose(x)        y = np.transpose(y)                x = np.around(x,2)        y = np.around(y,2)        # z = np.transpose(z)        xm = x + m_offset                    for xi in range(x_bin + 1):            for yi in range(y_bin + 1):                                for i in range(rep):                    file.write('\n')                    s1 = str(x[xi][yi])                    s2 = str(y[xi][yi])                    s3 = str(z[xi][yi])                    s4 = str(xm[xi][yi])                    list = [s1, s2, s3, s4]                    file.write('\t'.join(list))    elif mode == 'L':        if l_d == 'x':            y = l_pos            x = np.linspace(x_start, x_stop, x_bin + 1)            z_start = z1 + (z3 - z1) * (l_pos - y_start) / (y_stop - y_start)            z_stop = z2 + (z4 - z2) * (l_pos - y_start) / (y_stop - y_start)            z = np.linspace(z_start, z_stop, x_bin + 1)                        for i in range(x_bin + 1):                for i in range(rep):                    file.write('\n')                    s1 = x[i]                    s2 = y                    s3 = z[i]                    s4 = x[i] + m_offest                    list = [s1, s2, s3, s4]                    file.write('\t'.join(list))        elif l_d == 'y':            x = l_pos            y = np.linspace(y_start, y_stop, y_bin + 1)            z_start = z1 + (z3 - z1) * (l_pos - x_start) / (x_stop - x_start)            z_stop = z2 + (z4 - z2) * (l_pos - x_start) / (y_stop - x_start)            z = np.linspace(z_start, z_stop, y_bin + 1)            for i in range(y_bin + 1):                for i in range(rep):                    file.write('\n')                    s1 = x                    s2 = y[i]                    s3 = z[i]                    s4 = x + m_offest                    list = [s1, s2, s3, s4]                    file.write('\t'.join(list))        else:            raise Exception('Error: invalid sample direction. Please enter \'x\' or \'y\'.')    file.close()    # Origin of physical frame in motor coordinatesx0 = 49y0 = 91.3z0 = 59# Enter physical coordinates here. Assume positive x points to the rightx_start = 69        #0x_stop = 29         #-24 to righty_start = 91.3y_stop = 1.3# z coordinates are in motor coordinatesz1 =57.4z2 = 57.3z3 = 58z4 = 57.9x_bin = 2y_bin = 3m_offest = 50.5     # iffset betweeb lens 49 and mirror 99.5make_plane(x_start, x_stop, y_start, y_stop, z1, z2, z3, z4, x_bin, y_bin, m_offest, mode='P', rep=1)data=np.loadtxt(name,skiprows=3,)X, Y, Z = data[:,0], data[:,1], data[:,2]fig = plt.figure()ax = fig.add_subplot(111, projection='3d')ax.plot_trisurf(X, Y, Z, color='white', edgecolors='grey', alpha=0.5,lw=0.1)ax.set_xlabel('x')ax.set_ylabel('y')ax.set_zlabel('z')# ax.scatter(X, Y, Z, c='red',s=0.1)plt.show()